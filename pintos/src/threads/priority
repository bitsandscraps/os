./bochsout.txt:00000000000i[     ]   x86-64 support: no
./bochsout.txt:00000000000i[MEM0 ] rom at 0xf0000/65536 ('/usr/local/share/bochs/BIOS-bochs-latest')
./bochsout.txt:00000000000i[MEM0 ] rom at 0xc0000/32768 ('/usr/local/share/bochs/VGABIOS-lgpl-latest')
./bochsrc.txt:romimage: file=$BXSHARE/BIOS-bochs-latest, address=0xf0000
./bochsrc.txt:vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
./bochsrc.txt:ata0-master: type=disk, path=/tmp/OEEiYypZwI.dsk, mode=flat, cylinders=1, heads=16, spt=63, translation=none
./DESIGNDOC:			+--------------------+
./DESIGNDOC:			+--------------------+
./DESIGNDOC:---- GROUP ----
./DESIGNDOC:---- PRELIMINARIES ----
./DESIGNDOC:http://maplejune.tistory.com/entry/Pintos-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-1-Alarm-Clock
./DESIGNDOC:---- DATA STRUCTURES ----
./DESIGNDOC:---- ALGORITHMS ----
./DESIGNDOC:---- SYNCHRONIZATION ----
./DESIGNDOC:---- RATIONALE ----
./DESIGNDOC:---- DATA STRUCTURES ----
./DESIGNDOC:---- ALGORITHMS ----
./DESIGNDOC:>> on a lock that a higher-priority thread is waiting for.
./DESIGNDOC:---- SYNCHRONIZATION ----
./DESIGNDOC:---- RATIONALE ----
./DESIGNDOC:---- DATA STRUCTURES ----
./DESIGNDOC:---- ALGORITHMS ----
./DESIGNDOC:-----  --  --  --  --  --  --   ------
./DESIGNDOC:---- RATIONALE ----
./DESIGNDOC:>> C6: The assignment explains arithmetic for fixed-point math in
./DESIGNDOC:>> abstraction layer for fixed-point math, that is, an abstract data
./DESIGNDOC:>> type and/or a set of functions or macros to manipulate fixed-point
./DESIGNDOC:want--these questions are just to spur your thoughts.  You may also
./fixed-point.h:    return (x - FIXED_POINT_F / 2) / FIXED_POINT_F;
./fixed-point.h:  return x - y;
./fixed-point.h:  return x - n * FIXED_POINT_F;
./fixed-point.h:#endif /* threads/fixed-point.h */ 
./init.c:/* -f: Format the file system? */
./init.c:/* -q: Power off after kernel tasks complete? */
./init.c:  memset (&_start_bss, 0, &_end_bss - &_start_bss);
./init.c:     new page tables immediately.  See [IA32-v2a] "MOV--Move
./init.c:     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
./init.c:   an argv-like array. */
./init.c:      p += strnlen (p, end - p) + 1;
./init.c:   and returns the first non-option argument. */
./init.c:  for (; *argv != NULL && **argv == '-'; argv++)
./init.c:      if (!strcmp (name, "-h"))
./init.c:      else if (!strcmp (name, "-q"))
./init.c:      else if (!strcmp (name, "-f"))
./init.c:      else if (!strcmp (name, "-rs"))
./init.c:      else if (!strcmp (name, "-mlfqs"))
./init.c:      else if (!strcmp (name, "-ul"))
./init.c:        PANIC ("unknown option `%s' (use -h for help)", name);
./init.c:        if (a->name == NULL)
./init.c:          PANIC ("unknown action `%s' (use -h for help)", *argv);
./init.c:        else if (!strcmp (*argv, a->name))
./init.c:      for (i = 1; i < a->argc; i++)
./init.c:          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
./init.c:      a->function (argv);
./init.c:      argv += a->argc;
./init.c:          "Use these actions indirectly via `pintos' -g and -p options:\n"
./init.c:          "  -h                 Print this help message and power off.\n"
./init.c:          "  -q                 Power off VM after actions or on panic.\n"
./init.c:          "  -f                 Format file system disk during startup.\n"
./init.c:          "  -rs=SEED           Set random number seed to SEED.\n"
./init.c:          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
./init.c:          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
./init.h:/* -q: Power off when kernel tasks complete? */
./interrupt.c:#include "threads/intr-stubs.h"
./interrupt.c:   the CPU.  See [IA32-v3a] sections 5.10 "Interrupt Descriptor
./interrupt.c:   Exception- or Interrupt-Handler Procedure". */
./interrupt.c:   pre-empted.  Handlers for external interrupts also may not
./interrupt.c:     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
./interrupt.c:     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
./interrupt.c:     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
./interrupt.c:     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
./interrupt.c:     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
./interrupt.c:  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
./interrupt.c:  intr_names[14] = "#PF Page-Fault Exception";
./interrupt.c:  intr_names[16] = "#MF x87 FPU Floating-Point Error";
./interrupt.c:  intr_names[18] = "#MC Machine-Check Exception";
./interrupt.c:  intr_names[19] = "#XF SIMD Floating-Point Exception";
./interrupt.c:   the DPL or lower-numbered ring.  In practice, DPL==3 allows
./interrupt.c:   [IA32-v3a] sections 4.5 "Privilege Levels" and 4.8.1.1
./interrupt.c:  outb (0x21, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
./interrupt.c:  outb (0x21, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
./interrupt.c:  outb (0xa1, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
./interrupt.c:  outb (0xa1, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
./interrupt.c:/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
./interrupt.c:   or lower-numbered ring.  In practice, DPL==3 allows user mode
./interrupt.c:   DPL==0 to be invoked.  See [IA32-v3a] sections 4.5 "Privilege
./interrupt.c:   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
./interrupt.c:   Interrupt-Handler Procedure" for discussion. */
./interrupt.c:   intr-stubs.S.  FRAME describes the interrupt and the
./interrupt.c:  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
./interrupt.c:  handler = intr_handlers[frame->vec_no];
./interrupt.c:  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
./interrupt.c:      pic_end_of_interrupt (frame->vec_no); 
./interrupt.c:     See [IA32-v2a] "MOV--Move to/from Control Registers" and
./interrupt.c:     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
./interrupt.c:          f->vec_no, intr_names[f->vec_no], f->eip);
./interrupt.c:  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
./interrupt.c:          f->eax, f->ebx, f->ecx, f->edx);
./interrupt.c:          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
./interrupt.c:          f->cs, f->ds, f->es, f->ss);
./interrupt.h:    /* Pushed by intr_entry in intr-stubs.S.
./interrupt.h:    /* Pushed by intrNN_stub in intr-stubs.S. */
./interrupt.h:    /* Pushed by intrNN_stub in intr-stubs.S.
./intr-stubs.h:   These are little snippets of code in intr-stubs.S, one for
./intr-stubs.h:   See intr-stubs.S for more information.
./intr-stubs.h:#endif /* threads/intr-stubs.h */
./io.h:  /* See [IA32-v2a] "IN". */
./io.h:  /* See [IA32-v2a] "INS". */
./io.h:  /* See [IA32-v2a] "IN". */
./io.h:/* Reads CNT 16-bit (halfword) units from PORT, one after
./io.h:  /* See [IA32-v2a] "INS". */
./io.h:  /* See [IA32-v2a] "IN". */
./io.h:/* Reads CNT 32-bit (word) units from PORT, one after another,
./io.h:  /* See [IA32-v2a] "INS". */
./io.h:  /* See [IA32-v2b] "OUT". */
./io.h:/* Writes to PORT each byte of data in the CNT-byte buffer
./io.h:  /* See [IA32-v2b] "OUTS". */
./io.h:/* Writes the 16-bit DATA to PORT. */
./io.h:  /* See [IA32-v2b] "OUT". */
./io.h:/* Writes to PORT each 16-bit unit (halfword) of data in the
./io.h:   CNT-halfword buffer starting at ADDR. */
./io.h:  /* See [IA32-v2b] "OUTS". */
./io.h:/* Writes the 32-bit DATA to PORT. */
./io.h:  /* See [IA32-v2b] "OUT". */
./io.h:/* Writes to PORT each 32-bit unit (word) of data in the CNT-word
./io.h:  /* See [IA32-v2b] "OUTS". */
./kernel.lds.S:OUTPUT_FORMAT("elf32-i386")
./kernel.lds.S:  /* Kernel starts with code, followed by read-only data and writable data. */
./kernel.lds.S:  /* BSS (zero-initialized data) is after everything else. */
./loader.h:#define LOADER_SIG (LOADER_END - LOADER_SIG_LEN)   /* 0xaa55 BIOS signature. */
./loader.h:#define LOADER_ARGS (LOADER_SIG - LOADER_ARGS_LEN)     /* Command-line args. */
./loader.h:#define LOADER_ARG_CNT (LOADER_ARGS - LOADER_ARG_CNT_LEN) /* Number of args. */
./loader.h:#define LOADER_RAM_PGS (LOADER_ARG_CNT - LOADER_RAM_PGS_LEN) /* # RAM pages. */
./loader.S:#### 0x7c00-0x7e00 (512 bytes).  Then it jumps to the beginning of it,
./loader.S:#### in real mode.  This code switches into protected mode (32-bit
./loader.S:#define CR0_EM 0x00000004      /* (Floating-point) Emulation. */
./loader.S:#define CR0_WP 0x00010000      /* Write-Protect enable in kernel mode. */
./loader.S:# Code runs in real mode, which is a 16-bit segment.
./loader.S:#### clear if successful, with AX = (kB of physical memory) - 1024.
./loader.S:# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
./loader.S:# Set up one-to-map linear to physical map for the first 64 MB of RAM.
./loader.S:# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
./loader.S:#       write-protect bits in page tables (!).
./loader.S:#    EM (Emulation): forces floating-point instructions to trap.
./loader.S:# We're now in protected mode in a 16-bit segment.  The CPU still has
./loader.S:# the real-mode code segment cached in %cs's segment descriptor.  We
./loader.S:# Because we're not in a 32-bit segment the data32 prefix is needed to
./loader.S:# jump to a 32-bit offset.
./loader.S:# We're now in protected mode in a 32-bit segment.
./loader.S:	.word	0x17			# sizeof (gdt) - 1
./loader.S:	.org LOADER_RAM_PGS - LOADER_BASE
./loader.S:#### Command-line arguments and their count.
./loader.S:	.org LOADER_ARG_CNT - LOADER_BASE
./loader.S:	.org LOADER_ARGS - LOADER_BASE
./loader.S:#### Boot-sector signature.
./loader.S:	.org LOADER_SIG - LOADER_BASE
./Make.vars:# -*- makefile -*-
./Make.vars:SIMULATOR = --bochs
./malloc.c:   But if the arena that the block was in now has no in-use
./malloc.c:      d->block_size = block_size;
./malloc.c:      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
./malloc.c:      list_init (&d->free_list);
./malloc.c:      lock_init (&d->lock);
./malloc.c:  /* Find the smallest descriptor that satisfies a SIZE-byte
./malloc.c:    if (d->block_size >= size)
./malloc.c:      a->magic = ARENA_MAGIC;
./malloc.c:      a->desc = NULL;
./malloc.c:      a->free_cnt = page_cnt;
./malloc.c:  lock_acquire (&d->lock);
./malloc.c:  if (list_empty (&d->free_list))
./malloc.c:          lock_release (&d->lock);
./malloc.c:      a->magic = ARENA_MAGIC;
./malloc.c:      a->desc = d;
./malloc.c:      a->free_cnt = d->blocks_per_arena;
./malloc.c:      for (i = 0; i < d->blocks_per_arena; i++) 
./malloc.c:          list_push_back (&d->free_list, &b->free_elem);
./malloc.c:  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
./malloc.c:  a->free_cnt--;
./malloc.c:  lock_release (&d->lock);
./malloc.c:  struct desc *d = a->desc;
./malloc.c:  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
./malloc.c:      struct desc *d = a->desc;
./malloc.c:          /* Clear the block to help detect use-after-free bugs. */
./malloc.c:          memset (b, 0xcc, d->block_size);
./malloc.c:          lock_acquire (&d->lock);
./malloc.c:          list_push_front (&d->free_list, &b->free_elem);
./malloc.c:          if (++a->free_cnt >= d->blocks_per_arena) 
./malloc.c:              ASSERT (a->free_cnt == d->blocks_per_arena);
./malloc.c:              for (i = 0; i < d->blocks_per_arena; i++) 
./malloc.c:                  list_remove (&b->free_elem);
./malloc.c:          lock_release (&d->lock);
./malloc.c:          palloc_free_multiple (a, a->free_cnt);
./malloc.c:  ASSERT (a->magic == ARENA_MAGIC);
./malloc.c:  ASSERT (a->desc == NULL
./malloc.c:          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
./malloc.c:  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
./malloc.c:/* Returns the (IDX - 1)'th block within arena A. */
./malloc.c:  ASSERT (a->magic == ARENA_MAGIC);
./malloc.c:  ASSERT (idx < a->desc->blocks_per_arena);
./malloc.c:                           + idx * a->desc->block_size);
./palloc.c:/* Page allocator.  Hands out memory in page-size (or
./palloc.c:   page-multiple) chunks.  See malloc.h for an allocator that
./palloc.c:  size_t free_pages = (free_end - free_start) / PGSIZE;
./palloc.c:  kernel_pages = free_pages - user_pages;
./palloc.c:  lock_acquire (&pool->lock);
./palloc.c:  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
./palloc.c:  lock_release (&pool->lock);
./palloc.c:    pages = pool->base + PGSIZE * page_idx;
./palloc.c:  page_idx = pg_no (pages) - pg_no (pool->base);
./palloc.c:  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
./palloc.c:  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
./palloc.c:  page_cnt -= bm_pages;
./palloc.c:  lock_init (&p->lock);
./palloc.c:  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
./palloc.c:  p->base = base + bm_pages * PGSIZE;
./palloc.c:  size_t start_page = pg_no (pool->base);
./palloc.c:  size_t end_page = start_page + bitmap_size (pool->used_map);
./pte.h:   +----------------------+----------------------+----------------------+
./pte.h:   +----------------------+----------------------+----------------------+
./pte.h:   Pintos reference guide chapter, or [IA32-v3a] 3.7.6
./pte.h:   "Page-Directory and Page-Table Entries".
./pte.h:   +------------------------------------+------------------------+
./pte.h:   +------------------------------------+------------------------+
./pte.h:#define PTE_W 0x2               /* 1=read/write, 0=read-only. */
./switch.S:	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
./synch.c:/* Copyright (c) 1992-1996 The Regents of the University of California.
./synch.c:  return a_thr->priority < b_thr->priority;
./synch.c:   - down or "P": wait for the value to become positive, then
./synch.c:   - up or "V": increment the value (and wake up one waiting
./synch.c:  sema->value = value;
./synch.c:  list_init (&sema->waiters);
./synch.c:  while (sema->value == 0) 
./synch.c:      list_push_back (&sema->waiters, &thread_current ()->elem);
./synch.c:  sema->value--;
./synch.c:  if (sema->value > 0) 
./synch.c:      sema->value--;
./synch.c:  if (!list_empty (&sema->waiters))
./synch.c:    struct list_elem * max = list_max (&sema->waiters, lesser_priority, NULL);
./synch.c:  sema->value++;
./synch.c:    if (max_thr->priority > curr->priority)
./synch.c:/* Self-test for semaphores that makes control "ping-pong"
./synch.c:  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
./synch.c:  lock->holder = NULL;
./synch.c:  lock->priority = 0;
./synch.c:  sema_init (&lock->semaphore, 1);
./synch.c:  if (lock->holder != NULL) {
./synch.c:    curr->lock_trying_acquire = lock;
./synch.c:  sema_down (&lock->semaphore);
./synch.c:  curr->lock_trying_acquire = NULL;
./synch.c:  lock->holder = curr;
./synch.c:  lock->priority = curr->priority;
./synch.c:  list_push_back (&curr->locks_holding, &lock->elem);
./synch.c:  success = sema_try_down (&lock->semaphore);
./synch.c:    lock->holder = thread_current ();
./synch.c:  lock->holder = NULL;
./synch.c:  sema_up (&lock->semaphore);
./synch.c:  list_remove (&lock->elem);
./synch.c:  int orig_pri = curr->priority;
./synch.c:  if (orig_pri > curr->priority)
./synch.c:  return lock->holder == thread_current ();
./synch.c:  list_init (&cond->waiters);
./synch.c:  return a_sem->priority < b_sem->priority;
./synch.c:   condition variables.  That is, there is a one-to-many mapping
./synch.c:  waiter.priority = thread_current ()->priority;
./synch.c:  list_insert_ordered (&cond->waiters, &waiter.elem,
./synch.c:  if (!list_empty (&cond->waiters)) 
./synch.c:    sema_up (&list_entry (list_pop_back (&cond->waiters),
./synch.c:                          struct semaphore_elem, elem)->semaphore);
./synch.c:  while (!list_empty (&cond->waiters))
./thread.c:#include "threads/intr-stubs.h"
./thread.c:#include "threads/fixed-point.h"
./thread.c:/* If false (default), use round-robin scheduler.
./thread.c:   If true, use multi-level feedback queue scheduler.
./thread.c:   Controlled by kernel command-line option "-o mlfqs". */
./thread.c:  if(thread_current()->priority<thr->priority)
./thread.c:  thr->recent_cpu=fp_add_int(thr->recent_cpu, 1);
./thread.c:  pri_=fp_divide_int(thr->recent_cpu, 4);
./thread.c:  pri_=fp_subtract_int(pri_,2*thr->nice);
./thread.c:  thr->priority=new_pri;
./thread.c:    for(a=list_front(&thread_list);a!=list_end(&thread_list);a=a->next)
./thread.c:  thr->recent_cpu=fp_add_int(fp_multiply(thr->recent_cpu, cpu),
./thread.c:                             2*(thr->nice));
./thread.c:  for(a=list_begin(&thread_list);a!=list_end(&thread_list);a=a->next)
./thread.c:  return thread_current()->nice;
./thread.c:  thr->nice=new_nice;
./thread.c:  initial_thread->status = THREAD_RUNNING;
./thread.c:  initial_thread->tid = allocate_tid ();
./thread.c:  else if (t->pagedir != NULL)
./thread.c:  struct lock * lock = donor->lock_trying_acquire;
./thread.c:    struct thread * donee = lock->holder;
./thread.c:    if (donor->priority > donee->priority)
./thread.c:      donee->priority = donor->priority;
./thread.c:      lock->priority = donor->priority;
./thread.c:    lock = donee->lock_trying_acquire;
./thread.c:  int priority = thr->initial_priority;
./thread.c:  struct list * lock_list = &thr->locks_holding;
./thread.c:    if (priority < lock->priority)
./thread.c:      priority = lock->priority;
./thread.c:  thr->priority = priority;
./thread.c:   Priority scheduling is the goal of Problem 1-3. */
./thread.c:  tid = t->tid = allocate_tid ();
./thread.c:  kf->eip = NULL;
./thread.c:  kf->function = function;
./thread.c:  kf->aux = aux;
./thread.c:  ef->eip = (void (*) (void)) kernel_thread;
./thread.c:  sf->eip = switch_entry;
./thread.c:  if(priority > thread_current ()->priority)
./thread.c:  thread_current ()->status = THREAD_BLOCKED;
./thread.c:/* Transitions a blocked thread T to the ready-to-run state.
./thread.c:  ASSERT (t->status == THREAD_BLOCKED);
./thread.c:  list_insert_ordered(&ready_list, &t->elem, higher_priority, NULL);
./thread.c:  t->status = THREAD_READY;
./thread.c:  return thread_current ()->name;
./thread.c:  ASSERT (t->status == THREAD_RUNNING);
./thread.c:  return thread_current ()->tid;
./thread.c:  thread_current ()->status = THREAD_DYING;
./thread.c:  //thread_current()->elem_.prev->next=thread_current()->elem_.next;
./thread.c:  //thread_current()->elem_.next->prev=thread_current()->elem_.prev;
./thread.c:  curr->wakeup_tick = wakeup_tick;
./thread.c:  list_insert_ordered (&waiting_list, &curr->elem, lesser_wakeup_tick, NULL);
./thread.c:    list_insert_ordered(&ready_list, &curr->elem, higher_priority, NULL);
./thread.c:  curr->status = THREAD_READY;
./thread.c:  int old_priority = curr->priority;
./thread.c:  if (curr->priority == curr->initial_priority)
./thread.c:    curr->priority = new_priority;
./thread.c:  curr->initial_priority = new_priority;
./thread.c:  return thread_current ()->priority;
./thread.c:  return fp_round(fp_multiply_int(thread_current()->recent_cpu,100));
./thread.c:  return fp_round(fp_multiply_int(thread_current()->recent_cpu,100));
./thread.c:      /* Re-enable interrupts and wait for the next one.
./thread.c:         between re-enabling interrupts and waiting for the next
./thread.c:         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
./thread.c:    if (thr->wakeup_tick > current_tick)
./thread.c:    ASSERT (thr->status == THREAD_BLOCKED);
./thread.c:  return a_thr->wakeup_tick < b_thr->wakeup_tick;
./thread.c:  return a_thr->priority > b_thr->priority;
./thread.c:  return t != NULL && t->magic == THREAD_MAGIC;
./thread.c:  list_push_back(&thread_list, &t->elem_);
./thread.c:  t->status = THREAD_BLOCKED;
./thread.c:  strlcpy (t->name, name, sizeof t->name);
./thread.c:  t->stack = (uint8_t *) t + PGSIZE;
./thread.c:  t->priority = priority;
./thread.c:  t->recent_cpu=0;
./thread.c:  t->initial_priority = priority;
./thread.c:  list_init (&t->locks_holding);
./thread.c:  t->lock_trying_acquire = NULL;
./thread.c:  t->magic = THREAD_MAGIC;
./thread.c:/* Allocates a SIZE-byte frame at the top of thread T's stack and
./thread.c:  /* Stack data is always allocated in word-size units. */
./thread.c:  t->stack -= size;
./thread.c:  return t->stack;
./thread.c:  curr->status = THREAD_RUNNING;
./thread.c:  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
./thread.c:  ASSERT (curr->status != THREAD_RUNNING);
./thread.h:#include "threads/fixed-point.h"
./thread.h:#define TID_ERROR ((tid_t) -1)  /* Error value for tid_t. */
./thread.h:        4 kB +---------------------------------+
./thread.h:             +---------------------------------+
./thread.h:        0 kB +---------------------------------+
./thread.h:         structures or arrays as non-static local variables.  Use
./thread.h:/* If false (default), use round-robin scheduler.
./thread.h:   If true, use multi-level feedback queue scheduler.
./thread.h:   Controlled by kernel command-line option "-o mlfqs". */
./vaddr.h:#define BITMASK(SHIFT, CNT) (((1ul << (CNT)) - 1) << (SHIFT))
./vaddr.h:  return (void *) (((uintptr_t) va + PGSIZE - 1) & ~PGMASK);
./vaddr.h:/* Base address of the 1:1 physical-to-virtual mapping.  Physical
./vaddr.h:  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
