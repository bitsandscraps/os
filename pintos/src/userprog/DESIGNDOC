		     +--------------------------+
   	     |	      	EE 415      		|
		     | PROJECT 2: USER PROGRAMS	|
		     | 	   DESIGN DOCUMENT     	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Jongeui Park <qkrwhddml@kaist.ac.kr>
Seongsu Cho  <csp00141@kaist.ac.kr>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

Something was wrong with my DESIGNDOC for Assignment 1. I have fixed the
errors.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

From
http://bogus919.tistory.com/entry/pintos-project2
we got to know that we should change process_wait to infinite loop before
anything starts to work.

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Did not changed any data structured. If you can call macro a data
structure, we defined one macro.

/* The length of the array to store each argument during tokenizing
 * the given string. */
#define MAX_ARGC 64

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

First we strtok_r the given string to tokenize the name of the program,
and passed it to load. Second we kept strtok_r other parts of the string
and stored each token in the array of size MAX_ARGC. Then using the
array, we carefully arranged the arguments on the stack of the new
process.
  The string that the kernel passes to a process is maximum 128
characters long(LOADER_ARGS_LEN defined in threads/init.c). So the
maximum number of arguments will be 128 / 2 = 64, since there should be
at least one space between every arguments. So the whole argv array
cannot exceed (64 + 1) * 4 bytes, where 1 is the null pointer sentinel.
The left members of argument passing is argv, argc, and return address,
which is of total 12 bytes. So size of the whole argument passing stack
cannot exceed 128 + (64 + 1) * 4 + 12 = 784 bytes, which is much smaller
than the size of a page, 4 KB. The stack page will never overflow.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

strtok uses a static pointer to tokenize string. Since pintos is a
multi-threaded environment, it is very likely for race conditions to
occur and corrupt the results.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

First disadvantage of pintos-like approach is that we may hack the
kernel through malicious command-line arguments.


                              SYSTEM CALLS
                              ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration. Identify the purpose of each in 25 words or less.

A "fd_elem" is used to manage the file descriptors opened
by a particular process.

    struct fd_elem
    {
      int fd;                   /* assigned fd number */
      off_t pos;                /* offset for read and write */
      struct file * file;       /* struct file for the fd */
      struct list_elem elem;    /* list element of open_fds in struct thread */
    };

Lock to avoid race conditions on file system manipulations.

    static struct lock filesys_lock;

typedef of pid_t. In our implementation pid of a process is the
tid of its thread.

    typedef int pid_t;

Added to struct thread:

    /* For denying writes on executables. */
    struct file * executable;     /* The executable file of itself. */

    /* Data Structures for Managing File Descriptors. */
    struct list open_fds;         /* List of open files. */
    /* max_fd is always greater or equal to any files in open_fds.
     * This value is used to assign fd values to new files. */
    int max_fd;
    /* fd_lock must be acquired before modifying file descriptors. */
    struct lock fd_lock;

    /* Data Structues for Implementing Wait. */
    int exit_status;              /* Status of exit. */
    /* The value is 'up'ed when everything is over. */
    struct semaphore is_done;
    /* The value is 'up'ed when parent calls wait. */
    struct semaphore wait_parent;
    /* The value is 'up'ed when the data is ready for its parent. */
    struct semaphore wait_process;
    struct list children;         /* Children of the current process. */

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?


---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.


>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel. What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result? What about
>> for a system call that only copies 2 bytes of data? Is there room
>> for improvement in these numbers, and how much?


>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.



>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value. Such accesses must cause the
>> process to be terminated. System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point. This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling? Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed? In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues. Give an example.



---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading. How does your code ensure this? How is the load
>> success/failure status passed back to the thread that calls "exec"?


>> B8: Consider parent process P with child process C. How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits? After C exits? How do you ensure
>> that all resources are freed in each case? How about when P
>> terminates without waiting, before C exits? After C exits? Are
>> there any special cases?


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?


>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

Did not change the mapping. It makes implementation much simpler.


			SURVEY QUESTIONS
			================

Answering these questions is optional, but it will help us improve the
course in future quarters. ?Feel free to tell us anything you
want--these questions are just to spur your thoughts. You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard? Did it take too long or too little time?


>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?



>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems? Conversely, did you
>> find any of our guidance to be misleading?


>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?


>> Any other comments?

